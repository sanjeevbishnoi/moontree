// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'value_failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ValueFailure<T> {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;
}

/// @nodoc
abstract class _$$InvalidAmountCopyWith<T, $Res> {
  factory _$$InvalidAmountCopyWith(
          _$InvalidAmount<T> value, $Res Function(_$InvalidAmount<T>) then) =
      __$$InvalidAmountCopyWithImpl<T, $Res>;
  $Res call({double amount});
}

/// @nodoc
class __$$InvalidAmountCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidAmountCopyWith<T, $Res> {
  __$$InvalidAmountCopyWithImpl(
      _$InvalidAmount<T> _value, $Res Function(_$InvalidAmount<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidAmount<T>));

  @override
  _$InvalidAmount<T> get _value => super._value as _$InvalidAmount<T>;

  @override
  $Res call({
    Object? amount = freezed,
  }) {
    return _then(_$InvalidAmount<T>(
      amount == freezed
          ? _value.amount
          : amount // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$InvalidAmount<T> implements InvalidAmount<T> {
  const _$InvalidAmount(this.amount);

  @override
  final double amount;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidAmount(amount: $amount)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidAmount<T> &&
            const DeepCollectionEquality().equals(other.amount, amount));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(amount));

  @JsonKey(ignore: true)
  @override
  _$$InvalidAmountCopyWith<T, _$InvalidAmount<T>> get copyWith =>
      __$$InvalidAmountCopyWithImpl<T, _$InvalidAmount<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidAmount(amount);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidAmount?.call(amount);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount(amount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidAmount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidAmount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidAmount != null) {
      return invalidAmount(this);
    }
    return orElse();
  }
}

abstract class InvalidAmount<T> implements ValueFailure<T> {
  const factory InvalidAmount(final double amount) = _$InvalidAmount<T>;

  double get amount => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$InvalidAmountCopyWith<T, _$InvalidAmount<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidAssetNameCopyWith<T, $Res> {
  factory _$$InvalidAssetNameCopyWith(_$InvalidAssetName<T> value,
          $Res Function(_$InvalidAssetName<T>) then) =
      __$$InvalidAssetNameCopyWithImpl<T, $Res>;
  $Res call({String name});
}

/// @nodoc
class __$$InvalidAssetNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidAssetNameCopyWith<T, $Res> {
  __$$InvalidAssetNameCopyWithImpl(
      _$InvalidAssetName<T> _value, $Res Function(_$InvalidAssetName<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidAssetName<T>));

  @override
  _$InvalidAssetName<T> get _value => super._value as _$InvalidAssetName<T>;

  @override
  $Res call({
    Object? name = freezed,
  }) {
    return _then(_$InvalidAssetName<T>(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidAssetName<T> implements InvalidAssetName<T> {
  const _$InvalidAssetName(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidFullName(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidAssetName<T> &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$InvalidAssetNameCopyWith<T, _$InvalidAssetName<T>> get copyWith =>
      __$$InvalidAssetNameCopyWithImpl<T, _$InvalidAssetName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidFullName(name);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidFullName?.call(name);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidFullName != null) {
      return invalidFullName(name);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidFullName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidFullName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidFullName != null) {
      return invalidFullName(this);
    }
    return orElse();
  }
}

abstract class InvalidAssetName<T> implements ValueFailure<T> {
  const factory InvalidAssetName(final String name) = _$InvalidAssetName<T>;

  String get name => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$InvalidAssetNameCopyWith<T, _$InvalidAssetName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidTxIdCopyWith<T, $Res> {
  factory _$$InvalidTxIdCopyWith(
          _$InvalidTxId<T> value, $Res Function(_$InvalidTxId<T>) then) =
      __$$InvalidTxIdCopyWithImpl<T, $Res>;
  $Res call({String txId});
}

/// @nodoc
class __$$InvalidTxIdCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidTxIdCopyWith<T, $Res> {
  __$$InvalidTxIdCopyWithImpl(
      _$InvalidTxId<T> _value, $Res Function(_$InvalidTxId<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidTxId<T>));

  @override
  _$InvalidTxId<T> get _value => super._value as _$InvalidTxId<T>;

  @override
  $Res call({
    Object? txId = freezed,
  }) {
    return _then(_$InvalidTxId<T>(
      txId == freezed
          ? _value.txId
          : txId // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$InvalidTxId<T> implements InvalidTxId<T> {
  const _$InvalidTxId(this.txId);

  @override
  final String txId;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTxId(txId: $txId)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidTxId<T> &&
            const DeepCollectionEquality().equals(other.txId, txId));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(txId));

  @JsonKey(ignore: true)
  @override
  _$$InvalidTxIdCopyWith<T, _$InvalidTxId<T>> get copyWith =>
      __$$InvalidTxIdCopyWithImpl<T, _$InvalidTxId<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidTxId(txId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidTxId?.call(txId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxId != null) {
      return invalidTxId(txId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidTxId(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidTxId?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxId != null) {
      return invalidTxId(this);
    }
    return orElse();
  }
}

abstract class InvalidTxId<T> implements ValueFailure<T> {
  const factory InvalidTxId(final String txId) = _$InvalidTxId<T>;

  String get txId => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$InvalidTxIdCopyWith<T, _$InvalidTxId<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidTxDateCopyWith<T, $Res> {
  factory _$$InvalidTxDateCopyWith(
          _$InvalidTxDate<T> value, $Res Function(_$InvalidTxDate<T>) then) =
      __$$InvalidTxDateCopyWithImpl<T, $Res>;
  $Res call({DateTime date});
}

/// @nodoc
class __$$InvalidTxDateCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidTxDateCopyWith<T, $Res> {
  __$$InvalidTxDateCopyWithImpl(
      _$InvalidTxDate<T> _value, $Res Function(_$InvalidTxDate<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidTxDate<T>));

  @override
  _$InvalidTxDate<T> get _value => super._value as _$InvalidTxDate<T>;

  @override
  $Res call({
    Object? date = freezed,
  }) {
    return _then(_$InvalidTxDate<T>(
      date == freezed
          ? _value.date
          : date // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc

class _$InvalidTxDate<T> implements InvalidTxDate<T> {
  const _$InvalidTxDate(this.date);

  @override
  final DateTime date;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTxDate(date: $date)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidTxDate<T> &&
            const DeepCollectionEquality().equals(other.date, date));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(date));

  @JsonKey(ignore: true)
  @override
  _$$InvalidTxDateCopyWith<T, _$InvalidTxDate<T>> get copyWith =>
      __$$InvalidTxDateCopyWithImpl<T, _$InvalidTxDate<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidTxDate(date);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidTxDate?.call(date);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxDate != null) {
      return invalidTxDate(date);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidTxDate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidTxDate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxDate != null) {
      return invalidTxDate(this);
    }
    return orElse();
  }
}

abstract class InvalidTxDate<T> implements ValueFailure<T> {
  const factory InvalidTxDate(final DateTime date) = _$InvalidTxDate<T>;

  DateTime get date => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$InvalidTxDateCopyWith<T, _$InvalidTxDate<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidTxConfirmationsCopyWith<T, $Res> {
  factory _$$InvalidTxConfirmationsCopyWith(_$InvalidTxConfirmations<T> value,
          $Res Function(_$InvalidTxConfirmations<T>) then) =
      __$$InvalidTxConfirmationsCopyWithImpl<T, $Res>;
  $Res call({int txConfirmations});
}

/// @nodoc
class __$$InvalidTxConfirmationsCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidTxConfirmationsCopyWith<T, $Res> {
  __$$InvalidTxConfirmationsCopyWithImpl(_$InvalidTxConfirmations<T> _value,
      $Res Function(_$InvalidTxConfirmations<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidTxConfirmations<T>));

  @override
  _$InvalidTxConfirmations<T> get _value =>
      super._value as _$InvalidTxConfirmations<T>;

  @override
  $Res call({
    Object? txConfirmations = freezed,
  }) {
    return _then(_$InvalidTxConfirmations<T>(
      txConfirmations == freezed
          ? _value.txConfirmations
          : txConfirmations // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$InvalidTxConfirmations<T> implements InvalidTxConfirmations<T> {
  const _$InvalidTxConfirmations(this.txConfirmations);

  @override
  final int txConfirmations;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTxConfirmations(txConfirmations: $txConfirmations)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidTxConfirmations<T> &&
            const DeepCollectionEquality()
                .equals(other.txConfirmations, txConfirmations));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(txConfirmations));

  @JsonKey(ignore: true)
  @override
  _$$InvalidTxConfirmationsCopyWith<T, _$InvalidTxConfirmations<T>>
      get copyWith => __$$InvalidTxConfirmationsCopyWithImpl<T,
          _$InvalidTxConfirmations<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidTxConfirmations(txConfirmations);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidTxConfirmations?.call(txConfirmations);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxConfirmations != null) {
      return invalidTxConfirmations(txConfirmations);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidTxConfirmations(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidTxConfirmations?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxConfirmations != null) {
      return invalidTxConfirmations(this);
    }
    return orElse();
  }
}

abstract class InvalidTxConfirmations<T> implements ValueFailure<T> {
  const factory InvalidTxConfirmations(final int txConfirmations) =
      _$InvalidTxConfirmations<T>;

  int get txConfirmations => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$InvalidTxConfirmationsCopyWith<T, _$InvalidTxConfirmations<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidIpfsHashCopyWith<T, $Res> {
  factory _$$invalidIpfsHashCopyWith(_$invalidIpfsHash<T> value,
          $Res Function(_$invalidIpfsHash<T>) then) =
      __$$invalidIpfsHashCopyWithImpl<T, $Res>;
  $Res call({String ipfsHash});
}

/// @nodoc
class __$$invalidIpfsHashCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidIpfsHashCopyWith<T, $Res> {
  __$$invalidIpfsHashCopyWithImpl(
      _$invalidIpfsHash<T> _value, $Res Function(_$invalidIpfsHash<T>) _then)
      : super(_value, (v) => _then(v as _$invalidIpfsHash<T>));

  @override
  _$invalidIpfsHash<T> get _value => super._value as _$invalidIpfsHash<T>;

  @override
  $Res call({
    Object? ipfsHash = freezed,
  }) {
    return _then(_$invalidIpfsHash<T>(
      ipfsHash == freezed
          ? _value.ipfsHash
          : ipfsHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidIpfsHash<T> implements invalidIpfsHash<T> {
  const _$invalidIpfsHash(this.ipfsHash);

  @override
  final String ipfsHash;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidIpfsHash(ipfsHash: $ipfsHash)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidIpfsHash<T> &&
            const DeepCollectionEquality().equals(other.ipfsHash, ipfsHash));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(ipfsHash));

  @JsonKey(ignore: true)
  @override
  _$$invalidIpfsHashCopyWith<T, _$invalidIpfsHash<T>> get copyWith =>
      __$$invalidIpfsHashCopyWithImpl<T, _$invalidIpfsHash<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidIpfsHash(ipfsHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidIpfsHash?.call(ipfsHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidIpfsHash != null) {
      return invalidIpfsHash(ipfsHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidIpfsHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidIpfsHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidIpfsHash != null) {
      return invalidIpfsHash(this);
    }
    return orElse();
  }
}

abstract class invalidIpfsHash<T> implements ValueFailure<T> {
  const factory invalidIpfsHash(final String ipfsHash) = _$invalidIpfsHash<T>;

  String get ipfsHash => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidIpfsHashCopyWith<T, _$invalidIpfsHash<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidNoteCopyWith<T, $Res> {
  factory _$$invalidNoteCopyWith(
          _$invalidNote<T> value, $Res Function(_$invalidNote<T>) then) =
      __$$invalidNoteCopyWithImpl<T, $Res>;
  $Res call({String note});
}

/// @nodoc
class __$$invalidNoteCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidNoteCopyWith<T, $Res> {
  __$$invalidNoteCopyWithImpl(
      _$invalidNote<T> _value, $Res Function(_$invalidNote<T>) _then)
      : super(_value, (v) => _then(v as _$invalidNote<T>));

  @override
  _$invalidNote<T> get _value => super._value as _$invalidNote<T>;

  @override
  $Res call({
    Object? note = freezed,
  }) {
    return _then(_$invalidNote<T>(
      note == freezed
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidNote<T> implements invalidNote<T> {
  const _$invalidNote(this.note);

  @override
  final String note;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNote(note: $note)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidNote<T> &&
            const DeepCollectionEquality().equals(other.note, note));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(note));

  @JsonKey(ignore: true)
  @override
  _$$invalidNoteCopyWith<T, _$invalidNote<T>> get copyWith =>
      __$$invalidNoteCopyWithImpl<T, _$invalidNote<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidNote(note);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidNote?.call(note);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidNote != null) {
      return invalidNote(note);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidNote(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidNote?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidNote != null) {
      return invalidNote(this);
    }
    return orElse();
  }
}

abstract class invalidNote<T> implements ValueFailure<T> {
  const factory invalidNote(final String note) = _$invalidNote<T>;

  String get note => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidNoteCopyWith<T, _$invalidNote<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidMemoCopyWith<T, $Res> {
  factory _$$invalidMemoCopyWith(
          _$invalidMemo<T> value, $Res Function(_$invalidMemo<T>) then) =
      __$$invalidMemoCopyWithImpl<T, $Res>;
  $Res call({String memo});
}

/// @nodoc
class __$$invalidMemoCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidMemoCopyWith<T, $Res> {
  __$$invalidMemoCopyWithImpl(
      _$invalidMemo<T> _value, $Res Function(_$invalidMemo<T>) _then)
      : super(_value, (v) => _then(v as _$invalidMemo<T>));

  @override
  _$invalidMemo<T> get _value => super._value as _$invalidMemo<T>;

  @override
  $Res call({
    Object? memo = freezed,
  }) {
    return _then(_$invalidMemo<T>(
      memo == freezed
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidMemo<T> implements invalidMemo<T> {
  const _$invalidMemo(this.memo);

  @override
  final String memo;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidMemo(memo: $memo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidMemo<T> &&
            const DeepCollectionEquality().equals(other.memo, memo));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(memo));

  @JsonKey(ignore: true)
  @override
  _$$invalidMemoCopyWith<T, _$invalidMemo<T>> get copyWith =>
      __$$invalidMemoCopyWithImpl<T, _$invalidMemo<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidMemo(memo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidMemo?.call(memo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidMemo != null) {
      return invalidMemo(memo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidMemo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidMemo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidMemo != null) {
      return invalidMemo(this);
    }
    return orElse();
  }
}

abstract class invalidMemo<T> implements ValueFailure<T> {
  const factory invalidMemo(final String memo) = _$invalidMemo<T>;

  String get memo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidMemoCopyWith<T, _$invalidMemo<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidFeesCopyWith<T, $Res> {
  factory _$$invalidFeesCopyWith(
          _$invalidFees<T> value, $Res Function(_$invalidFees<T>) then) =
      __$$invalidFeesCopyWithImpl<T, $Res>;
  $Res call({Map<FeeType, Amount> fees});
}

/// @nodoc
class __$$invalidFeesCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidFeesCopyWith<T, $Res> {
  __$$invalidFeesCopyWithImpl(
      _$invalidFees<T> _value, $Res Function(_$invalidFees<T>) _then)
      : super(_value, (v) => _then(v as _$invalidFees<T>));

  @override
  _$invalidFees<T> get _value => super._value as _$invalidFees<T>;

  @override
  $Res call({
    Object? fees = freezed,
  }) {
    return _then(_$invalidFees<T>(
      fees == freezed
          ? _value._fees
          : fees // ignore: cast_nullable_to_non_nullable
              as Map<FeeType, Amount>,
    ));
  }
}

/// @nodoc

class _$invalidFees<T> implements invalidFees<T> {
  const _$invalidFees(final Map<FeeType, Amount> fees) : _fees = fees;

  final Map<FeeType, Amount> _fees;
  @override
  Map<FeeType, Amount> get fees {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_fees);
  }

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidFees(fees: $fees)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidFees<T> &&
            const DeepCollectionEquality().equals(other._fees, _fees));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_fees));

  @JsonKey(ignore: true)
  @override
  _$$invalidFeesCopyWith<T, _$invalidFees<T>> get copyWith =>
      __$$invalidFeesCopyWithImpl<T, _$invalidFees<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidFees(fees);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidFees?.call(fees);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidFees != null) {
      return invalidFees(fees);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidFees(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidFees?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidFees != null) {
      return invalidFees(this);
    }
    return orElse();
  }
}

abstract class invalidFees<T> implements ValueFailure<T> {
  const factory invalidFees(final Map<FeeType, Amount> fees) = _$invalidFees<T>;

  Map<FeeType, Amount> get fees => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidFeesCopyWith<T, _$invalidFees<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidWalletNameCopyWith<T, $Res> {
  factory _$$invalidWalletNameCopyWith(_$invalidWalletName<T> value,
          $Res Function(_$invalidWalletName<T>) then) =
      __$$invalidWalletNameCopyWithImpl<T, $Res>;
  $Res call({String note});
}

/// @nodoc
class __$$invalidWalletNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidWalletNameCopyWith<T, $Res> {
  __$$invalidWalletNameCopyWithImpl(_$invalidWalletName<T> _value,
      $Res Function(_$invalidWalletName<T>) _then)
      : super(_value, (v) => _then(v as _$invalidWalletName<T>));

  @override
  _$invalidWalletName<T> get _value => super._value as _$invalidWalletName<T>;

  @override
  $Res call({
    Object? note = freezed,
  }) {
    return _then(_$invalidWalletName<T>(
      note == freezed
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidWalletName<T> implements invalidWalletName<T> {
  const _$invalidWalletName(this.note);

  @override
  final String note;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidWalletName(note: $note)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidWalletName<T> &&
            const DeepCollectionEquality().equals(other.note, note));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(note));

  @JsonKey(ignore: true)
  @override
  _$$invalidWalletNameCopyWith<T, _$invalidWalletName<T>> get copyWith =>
      __$$invalidWalletNameCopyWithImpl<T, _$invalidWalletName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidWalletName(note);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidWalletName?.call(note);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidWalletName != null) {
      return invalidWalletName(note);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidWalletName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidWalletName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidWalletName != null) {
      return invalidWalletName(this);
    }
    return orElse();
  }
}

abstract class invalidWalletName<T> implements ValueFailure<T> {
  const factory invalidWalletName(final String note) = _$invalidWalletName<T>;

  String get note => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidWalletNameCopyWith<T, _$invalidWalletName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidHashedEntropyCopyWith<T, $Res> {
  factory _$$invalidHashedEntropyCopyWith(_$invalidHashedEntropy<T> value,
          $Res Function(_$invalidHashedEntropy<T>) then) =
      __$$invalidHashedEntropyCopyWithImpl<T, $Res>;
  $Res call({String memo});
}

/// @nodoc
class __$$invalidHashedEntropyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidHashedEntropyCopyWith<T, $Res> {
  __$$invalidHashedEntropyCopyWithImpl(_$invalidHashedEntropy<T> _value,
      $Res Function(_$invalidHashedEntropy<T>) _then)
      : super(_value, (v) => _then(v as _$invalidHashedEntropy<T>));

  @override
  _$invalidHashedEntropy<T> get _value =>
      super._value as _$invalidHashedEntropy<T>;

  @override
  $Res call({
    Object? memo = freezed,
  }) {
    return _then(_$invalidHashedEntropy<T>(
      memo == freezed
          ? _value.memo
          : memo // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidHashedEntropy<T> implements invalidHashedEntropy<T> {
  const _$invalidHashedEntropy(this.memo);

  @override
  final String memo;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidHashedEntropy(memo: $memo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidHashedEntropy<T> &&
            const DeepCollectionEquality().equals(other.memo, memo));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(memo));

  @JsonKey(ignore: true)
  @override
  _$$invalidHashedEntropyCopyWith<T, _$invalidHashedEntropy<T>> get copyWith =>
      __$$invalidHashedEntropyCopyWithImpl<T, _$invalidHashedEntropy<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidHashedEntropy(memo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidHashedEntropy?.call(memo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidHashedEntropy != null) {
      return invalidHashedEntropy(memo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidHashedEntropy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidHashedEntropy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidHashedEntropy != null) {
      return invalidHashedEntropy(this);
    }
    return orElse();
  }
}

abstract class invalidHashedEntropy<T> implements ValueFailure<T> {
  const factory invalidHashedEntropy(final String memo) =
      _$invalidHashedEntropy<T>;

  String get memo => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidHashedEntropyCopyWith<T, _$invalidHashedEntropy<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidPrivKeyCopyWith<T, $Res> {
  factory _$$invalidPrivKeyCopyWith(
          _$invalidPrivKey<T> value, $Res Function(_$invalidPrivKey<T>) then) =
      __$$invalidPrivKeyCopyWithImpl<T, $Res>;
  $Res call({String privKey});
}

/// @nodoc
class __$$invalidPrivKeyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidPrivKeyCopyWith<T, $Res> {
  __$$invalidPrivKeyCopyWithImpl(
      _$invalidPrivKey<T> _value, $Res Function(_$invalidPrivKey<T>) _then)
      : super(_value, (v) => _then(v as _$invalidPrivKey<T>));

  @override
  _$invalidPrivKey<T> get _value => super._value as _$invalidPrivKey<T>;

  @override
  $Res call({
    Object? privKey = freezed,
  }) {
    return _then(_$invalidPrivKey<T>(
      privKey == freezed
          ? _value.privKey
          : privKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidPrivKey<T> implements invalidPrivKey<T> {
  const _$invalidPrivKey(this.privKey);

  @override
  final String privKey;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPrivKey(privKey: $privKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidPrivKey<T> &&
            const DeepCollectionEquality().equals(other.privKey, privKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(privKey));

  @JsonKey(ignore: true)
  @override
  _$$invalidPrivKeyCopyWith<T, _$invalidPrivKey<T>> get copyWith =>
      __$$invalidPrivKeyCopyWithImpl<T, _$invalidPrivKey<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidPrivKey(privKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidPrivKey?.call(privKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPrivKey != null) {
      return invalidPrivKey(privKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidPrivKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidPrivKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPrivKey != null) {
      return invalidPrivKey(this);
    }
    return orElse();
  }
}

abstract class invalidPrivKey<T> implements ValueFailure<T> {
  const factory invalidPrivKey(final String privKey) = _$invalidPrivKey<T>;

  String get privKey => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidPrivKeyCopyWith<T, _$invalidPrivKey<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidPubKeyCopyWith<T, $Res> {
  factory _$$invalidPubKeyCopyWith(
          _$invalidPubKey<T> value, $Res Function(_$invalidPubKey<T>) then) =
      __$$invalidPubKeyCopyWithImpl<T, $Res>;
  $Res call({String pubKey});
}

/// @nodoc
class __$$invalidPubKeyCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidPubKeyCopyWith<T, $Res> {
  __$$invalidPubKeyCopyWithImpl(
      _$invalidPubKey<T> _value, $Res Function(_$invalidPubKey<T>) _then)
      : super(_value, (v) => _then(v as _$invalidPubKey<T>));

  @override
  _$invalidPubKey<T> get _value => super._value as _$invalidPubKey<T>;

  @override
  $Res call({
    Object? pubKey = freezed,
  }) {
    return _then(_$invalidPubKey<T>(
      pubKey == freezed
          ? _value.pubKey
          : pubKey // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidPubKey<T> implements invalidPubKey<T> {
  const _$invalidPubKey(this.pubKey);

  @override
  final String pubKey;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPubKey(pubKey: $pubKey)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidPubKey<T> &&
            const DeepCollectionEquality().equals(other.pubKey, pubKey));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(pubKey));

  @JsonKey(ignore: true)
  @override
  _$$invalidPubKeyCopyWith<T, _$invalidPubKey<T>> get copyWith =>
      __$$invalidPubKeyCopyWithImpl<T, _$invalidPubKey<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidPubKey(pubKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidPubKey?.call(pubKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPubKey != null) {
      return invalidPubKey(pubKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidPubKey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidPubKey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPubKey != null) {
      return invalidPubKey(this);
    }
    return orElse();
  }
}

abstract class invalidPubKey<T> implements ValueFailure<T> {
  const factory invalidPubKey(final String pubKey) = _$invalidPubKey<T>;

  String get pubKey => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidPubKeyCopyWith<T, _$invalidPubKey<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidPubKeyAddressCopyWith<T, $Res> {
  factory _$$invalidPubKeyAddressCopyWith(_$invalidPubKeyAddress<T> value,
          $Res Function(_$invalidPubKeyAddress<T>) then) =
      __$$invalidPubKeyAddressCopyWithImpl<T, $Res>;
  $Res call({String address});
}

/// @nodoc
class __$$invalidPubKeyAddressCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidPubKeyAddressCopyWith<T, $Res> {
  __$$invalidPubKeyAddressCopyWithImpl(_$invalidPubKeyAddress<T> _value,
      $Res Function(_$invalidPubKeyAddress<T>) _then)
      : super(_value, (v) => _then(v as _$invalidPubKeyAddress<T>));

  @override
  _$invalidPubKeyAddress<T> get _value =>
      super._value as _$invalidPubKeyAddress<T>;

  @override
  $Res call({
    Object? address = freezed,
  }) {
    return _then(_$invalidPubKeyAddress<T>(
      address == freezed
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidPubKeyAddress<T> implements invalidPubKeyAddress<T> {
  const _$invalidPubKeyAddress(this.address);

  @override
  final String address;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidPubKeyAddress(address: $address)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidPubKeyAddress<T> &&
            const DeepCollectionEquality().equals(other.address, address));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(address));

  @JsonKey(ignore: true)
  @override
  _$$invalidPubKeyAddressCopyWith<T, _$invalidPubKeyAddress<T>> get copyWith =>
      __$$invalidPubKeyAddressCopyWithImpl<T, _$invalidPubKeyAddress<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidPubKeyAddress(address);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidPubKeyAddress?.call(address);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPubKeyAddress != null) {
      return invalidPubKeyAddress(address);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidPubKeyAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidPubKeyAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidPubKeyAddress != null) {
      return invalidPubKeyAddress(this);
    }
    return orElse();
  }
}

abstract class invalidPubKeyAddress<T> implements ValueFailure<T> {
  const factory invalidPubKeyAddress(final String address) =
      _$invalidPubKeyAddress<T>;

  String get address => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidPubKeyAddressCopyWith<T, _$invalidPubKeyAddress<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidDerivationPathCopyWith<T, $Res> {
  factory _$$invalidDerivationPathCopyWith(_$invalidDerivationPath<T> value,
          $Res Function(_$invalidDerivationPath<T>) then) =
      __$$invalidDerivationPathCopyWithImpl<T, $Res>;
  $Res call({String derivationPath});
}

/// @nodoc
class __$$invalidDerivationPathCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidDerivationPathCopyWith<T, $Res> {
  __$$invalidDerivationPathCopyWithImpl(_$invalidDerivationPath<T> _value,
      $Res Function(_$invalidDerivationPath<T>) _then)
      : super(_value, (v) => _then(v as _$invalidDerivationPath<T>));

  @override
  _$invalidDerivationPath<T> get _value =>
      super._value as _$invalidDerivationPath<T>;

  @override
  $Res call({
    Object? derivationPath = freezed,
  }) {
    return _then(_$invalidDerivationPath<T>(
      derivationPath == freezed
          ? _value.derivationPath
          : derivationPath // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidDerivationPath<T> implements invalidDerivationPath<T> {
  const _$invalidDerivationPath(this.derivationPath);

  @override
  final String derivationPath;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidDerivationPath(derivationPath: $derivationPath)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidDerivationPath<T> &&
            const DeepCollectionEquality()
                .equals(other.derivationPath, derivationPath));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(derivationPath));

  @JsonKey(ignore: true)
  @override
  _$$invalidDerivationPathCopyWith<T, _$invalidDerivationPath<T>>
      get copyWith =>
          __$$invalidDerivationPathCopyWithImpl<T, _$invalidDerivationPath<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidDerivationPath(derivationPath);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidDerivationPath?.call(derivationPath);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidDerivationPath != null) {
      return invalidDerivationPath(derivationPath);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidDerivationPath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidDerivationPath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidDerivationPath != null) {
      return invalidDerivationPath(this);
    }
    return orElse();
  }
}

abstract class invalidDerivationPath<T> implements ValueFailure<T> {
  const factory invalidDerivationPath(final String derivationPath) =
      _$invalidDerivationPath<T>;

  String get derivationPath => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidDerivationPathCopyWith<T, _$invalidDerivationPath<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidTxPositionCopyWith<T, $Res> {
  factory _$$invalidTxPositionCopyWith(_$invalidTxPosition<T> value,
          $Res Function(_$invalidTxPosition<T>) then) =
      __$$invalidTxPositionCopyWithImpl<T, $Res>;
  $Res call({int position});
}

/// @nodoc
class __$$invalidTxPositionCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidTxPositionCopyWith<T, $Res> {
  __$$invalidTxPositionCopyWithImpl(_$invalidTxPosition<T> _value,
      $Res Function(_$invalidTxPosition<T>) _then)
      : super(_value, (v) => _then(v as _$invalidTxPosition<T>));

  @override
  _$invalidTxPosition<T> get _value => super._value as _$invalidTxPosition<T>;

  @override
  $Res call({
    Object? position = freezed,
  }) {
    return _then(_$invalidTxPosition<T>(
      position == freezed
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$invalidTxPosition<T> implements invalidTxPosition<T> {
  const _$invalidTxPosition(this.position);

  @override
  final int position;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTxPosition(position: $position)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidTxPosition<T> &&
            const DeepCollectionEquality().equals(other.position, position));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(position));

  @JsonKey(ignore: true)
  @override
  _$$invalidTxPositionCopyWith<T, _$invalidTxPosition<T>> get copyWith =>
      __$$invalidTxPositionCopyWithImpl<T, _$invalidTxPosition<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidTxPosition(position);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidTxPosition?.call(position);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxPosition != null) {
      return invalidTxPosition(position);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidTxPosition(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidTxPosition?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxPosition != null) {
      return invalidTxPosition(this);
    }
    return orElse();
  }
}

abstract class invalidTxPosition<T> implements ValueFailure<T> {
  const factory invalidTxPosition(final int position) = _$invalidTxPosition<T>;

  int get position => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidTxPositionCopyWith<T, _$invalidTxPosition<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidLockingScriptCopyWith<T, $Res> {
  factory _$$invalidLockingScriptCopyWith(_$invalidLockingScript<T> value,
          $Res Function(_$invalidLockingScript<T>) then) =
      __$$invalidLockingScriptCopyWithImpl<T, $Res>;
  $Res call({String script});
}

/// @nodoc
class __$$invalidLockingScriptCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidLockingScriptCopyWith<T, $Res> {
  __$$invalidLockingScriptCopyWithImpl(_$invalidLockingScript<T> _value,
      $Res Function(_$invalidLockingScript<T>) _then)
      : super(_value, (v) => _then(v as _$invalidLockingScript<T>));

  @override
  _$invalidLockingScript<T> get _value =>
      super._value as _$invalidLockingScript<T>;

  @override
  $Res call({
    Object? script = freezed,
  }) {
    return _then(_$invalidLockingScript<T>(
      script == freezed
          ? _value.script
          : script // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidLockingScript<T> implements invalidLockingScript<T> {
  const _$invalidLockingScript(this.script);

  @override
  final String script;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidLockingScript(script: $script)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidLockingScript<T> &&
            const DeepCollectionEquality().equals(other.script, script));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(script));

  @JsonKey(ignore: true)
  @override
  _$$invalidLockingScriptCopyWith<T, _$invalidLockingScript<T>> get copyWith =>
      __$$invalidLockingScriptCopyWithImpl<T, _$invalidLockingScript<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidLockingScript(script);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidLockingScript?.call(script);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidLockingScript != null) {
      return invalidLockingScript(script);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidLockingScript(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidLockingScript?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidLockingScript != null) {
      return invalidLockingScript(this);
    }
    return orElse();
  }
}

abstract class invalidLockingScript<T> implements ValueFailure<T> {
  const factory invalidLockingScript(final String script) =
      _$invalidLockingScript<T>;

  String get script => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidLockingScriptCopyWith<T, _$invalidLockingScript<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidProtocolCopyWith<T, $Res> {
  factory _$$invalidProtocolCopyWith(_$invalidProtocol<T> value,
          $Res Function(_$invalidProtocol<T>) then) =
      __$$invalidProtocolCopyWithImpl<T, $Res>;
  $Res call({Protocols protocol});
}

/// @nodoc
class __$$invalidProtocolCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidProtocolCopyWith<T, $Res> {
  __$$invalidProtocolCopyWithImpl(
      _$invalidProtocol<T> _value, $Res Function(_$invalidProtocol<T>) _then)
      : super(_value, (v) => _then(v as _$invalidProtocol<T>));

  @override
  _$invalidProtocol<T> get _value => super._value as _$invalidProtocol<T>;

  @override
  $Res call({
    Object? protocol = freezed,
  }) {
    return _then(_$invalidProtocol<T>(
      protocol == freezed
          ? _value.protocol
          : protocol // ignore: cast_nullable_to_non_nullable
              as Protocols,
    ));
  }
}

/// @nodoc

class _$invalidProtocol<T> implements invalidProtocol<T> {
  const _$invalidProtocol(this.protocol);

  @override
  final Protocols protocol;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidProtocol(protocol: $protocol)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidProtocol<T> &&
            const DeepCollectionEquality().equals(other.protocol, protocol));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(protocol));

  @JsonKey(ignore: true)
  @override
  _$$invalidProtocolCopyWith<T, _$invalidProtocol<T>> get copyWith =>
      __$$invalidProtocolCopyWithImpl<T, _$invalidProtocol<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidProtocol(protocol);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidProtocol?.call(protocol);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidProtocol != null) {
      return invalidProtocol(protocol);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidProtocol(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidProtocol?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidProtocol != null) {
      return invalidProtocol(this);
    }
    return orElse();
  }
}

abstract class invalidProtocol<T> implements ValueFailure<T> {
  const factory invalidProtocol(final Protocols protocol) =
      _$invalidProtocol<T>;

  Protocols get protocol => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidProtocolCopyWith<T, _$invalidProtocol<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$invalidTxHashCopyWith<T, $Res> {
  factory _$$invalidTxHashCopyWith(
          _$invalidTxHash<T> value, $Res Function(_$invalidTxHash<T>) then) =
      __$$invalidTxHashCopyWithImpl<T, $Res>;
  $Res call({String txHash});
}

/// @nodoc
class __$$invalidTxHashCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$invalidTxHashCopyWith<T, $Res> {
  __$$invalidTxHashCopyWithImpl(
      _$invalidTxHash<T> _value, $Res Function(_$invalidTxHash<T>) _then)
      : super(_value, (v) => _then(v as _$invalidTxHash<T>));

  @override
  _$invalidTxHash<T> get _value => super._value as _$invalidTxHash<T>;

  @override
  $Res call({
    Object? txHash = freezed,
  }) {
    return _then(_$invalidTxHash<T>(
      txHash == freezed
          ? _value.txHash
          : txHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$invalidTxHash<T> implements invalidTxHash<T> {
  const _$invalidTxHash(this.txHash);

  @override
  final String txHash;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidTxHash(txHash: $txHash)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$invalidTxHash<T> &&
            const DeepCollectionEquality().equals(other.txHash, txHash));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(txHash));

  @JsonKey(ignore: true)
  @override
  _$$invalidTxHashCopyWith<T, _$invalidTxHash<T>> get copyWith =>
      __$$invalidTxHashCopyWithImpl<T, _$invalidTxHash<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(double amount) invalidAmount,
    required TResult Function(String name) invalidFullName,
    required TResult Function(String txId) invalidTxId,
    required TResult Function(DateTime date) invalidTxDate,
    required TResult Function(int txConfirmations) invalidTxConfirmations,
    required TResult Function(String ipfsHash) invalidIpfsHash,
    required TResult Function(String note) invalidNote,
    required TResult Function(String memo) invalidMemo,
    required TResult Function(Map<FeeType, Amount> fees) invalidFees,
    required TResult Function(String note) invalidWalletName,
    required TResult Function(String memo) invalidHashedEntropy,
    required TResult Function(String privKey) invalidPrivKey,
    required TResult Function(String pubKey) invalidPubKey,
    required TResult Function(String address) invalidPubKeyAddress,
    required TResult Function(String derivationPath) invalidDerivationPath,
    required TResult Function(int position) invalidTxPosition,
    required TResult Function(String script) invalidLockingScript,
    required TResult Function(Protocols protocol) invalidProtocol,
    required TResult Function(String txHash) invalidTxHash,
  }) {
    return invalidTxHash(txHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
  }) {
    return invalidTxHash?.call(txHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(double amount)? invalidAmount,
    TResult Function(String name)? invalidFullName,
    TResult Function(String txId)? invalidTxId,
    TResult Function(DateTime date)? invalidTxDate,
    TResult Function(int txConfirmations)? invalidTxConfirmations,
    TResult Function(String ipfsHash)? invalidIpfsHash,
    TResult Function(String note)? invalidNote,
    TResult Function(String memo)? invalidMemo,
    TResult Function(Map<FeeType, Amount> fees)? invalidFees,
    TResult Function(String note)? invalidWalletName,
    TResult Function(String memo)? invalidHashedEntropy,
    TResult Function(String privKey)? invalidPrivKey,
    TResult Function(String pubKey)? invalidPubKey,
    TResult Function(String address)? invalidPubKeyAddress,
    TResult Function(String derivationPath)? invalidDerivationPath,
    TResult Function(int position)? invalidTxPosition,
    TResult Function(String script)? invalidLockingScript,
    TResult Function(Protocols protocol)? invalidProtocol,
    TResult Function(String txHash)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxHash != null) {
      return invalidTxHash(txHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidAmount<T> value) invalidAmount,
    required TResult Function(InvalidAssetName<T> value) invalidFullName,
    required TResult Function(InvalidTxId<T> value) invalidTxId,
    required TResult Function(InvalidTxDate<T> value) invalidTxDate,
    required TResult Function(InvalidTxConfirmations<T> value)
        invalidTxConfirmations,
    required TResult Function(invalidIpfsHash<T> value) invalidIpfsHash,
    required TResult Function(invalidNote<T> value) invalidNote,
    required TResult Function(invalidMemo<T> value) invalidMemo,
    required TResult Function(invalidFees<T> value) invalidFees,
    required TResult Function(invalidWalletName<T> value) invalidWalletName,
    required TResult Function(invalidHashedEntropy<T> value)
        invalidHashedEntropy,
    required TResult Function(invalidPrivKey<T> value) invalidPrivKey,
    required TResult Function(invalidPubKey<T> value) invalidPubKey,
    required TResult Function(invalidPubKeyAddress<T> value)
        invalidPubKeyAddress,
    required TResult Function(invalidDerivationPath<T> value)
        invalidDerivationPath,
    required TResult Function(invalidTxPosition<T> value) invalidTxPosition,
    required TResult Function(invalidLockingScript<T> value)
        invalidLockingScript,
    required TResult Function(invalidProtocol<T> value) invalidProtocol,
    required TResult Function(invalidTxHash<T> value) invalidTxHash,
  }) {
    return invalidTxHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
  }) {
    return invalidTxHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidAmount<T> value)? invalidAmount,
    TResult Function(InvalidAssetName<T> value)? invalidFullName,
    TResult Function(InvalidTxId<T> value)? invalidTxId,
    TResult Function(InvalidTxDate<T> value)? invalidTxDate,
    TResult Function(InvalidTxConfirmations<T> value)? invalidTxConfirmations,
    TResult Function(invalidIpfsHash<T> value)? invalidIpfsHash,
    TResult Function(invalidNote<T> value)? invalidNote,
    TResult Function(invalidMemo<T> value)? invalidMemo,
    TResult Function(invalidFees<T> value)? invalidFees,
    TResult Function(invalidWalletName<T> value)? invalidWalletName,
    TResult Function(invalidHashedEntropy<T> value)? invalidHashedEntropy,
    TResult Function(invalidPrivKey<T> value)? invalidPrivKey,
    TResult Function(invalidPubKey<T> value)? invalidPubKey,
    TResult Function(invalidPubKeyAddress<T> value)? invalidPubKeyAddress,
    TResult Function(invalidDerivationPath<T> value)? invalidDerivationPath,
    TResult Function(invalidTxPosition<T> value)? invalidTxPosition,
    TResult Function(invalidLockingScript<T> value)? invalidLockingScript,
    TResult Function(invalidProtocol<T> value)? invalidProtocol,
    TResult Function(invalidTxHash<T> value)? invalidTxHash,
    required TResult orElse(),
  }) {
    if (invalidTxHash != null) {
      return invalidTxHash(this);
    }
    return orElse();
  }
}

abstract class invalidTxHash<T> implements ValueFailure<T> {
  const factory invalidTxHash(final String txHash) = _$invalidTxHash<T>;

  String get txHash => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$$invalidTxHashCopyWith<T, _$invalidTxHash<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
